# -*- coding: utf-8 -*-
# Generated by Django 1.11.15 on 2018-09-10 18:21
from __future__ import unicode_literals

from django.db import migrations
from django.db import connection


def table_exists(tablename):
    cursor = connection.cursor()
    cursor.execute(
        """SELECT EXISTS (SELECT * FROM pg_tables WHERE tablename ='{}');""".format(tablename)
    )
    return cursor.fetchone()[0]


def ashlar_record_to_driverrecord(apps, schema_editor):
    if table_exists('ashlar_record'):
        cursor = connection.cursor()
        cursor.execute(
            """INSERT INTO data_driverrecord
            (record_ptr_id, weather, light, city, city_district, county, neighborhood, road, state)
            SELECT uuid, weather, light, city, city_district, county, neighborhood, road, state
            FROM ashlar_record;"""
        )


def clear_driverrecord(apps, schema_editor):
    if table_exists('ashlar_record'):
        cursor = connection.cursor()
        cursor.execute('DELETE FROM data_driverrecord;')


class Migration(migrations.Migration):

    dependencies = [
        ('data', '0012_add_driver_record_model'),
    ]

    operations = [
        # Copy over the old Ashlar data that is missing from Grout into the DriverRecord model
        # table.
        migrations.RunPython(ashlar_record_to_driverrecord, clear_driverrecord),
        # The pre-migration state is to have UUIDs in record_id columns and nulls in
        # driver_record_id columns. We want to have the same data in both columns but pointing to
        # different tables. On forward, we copy record_id -> driver_record_id. On reverse, we first
        # copy driver_record_id -> record_id to ensure that no data is lost, and then nullify
        # driver_record_id.
        migrations.RunSQL(
            'UPDATE data_recordauditlogentry SET driver_record_id = record_id;',
            'UPDATE data_recordauditlogentry SET driver_record_id = NULL;'
        ),
        migrations.RunSQL(
            """UPDATE data_recordduplicate SET driver_record_id = record_id,
               driver_duplicate_record_id = duplicate_record_id;""",
            """UPDATE data_recordduplicate SET driver_record_id = NULL,
               driver_duplicate_record_id = NULL;"""
        ),
        # Need to do this first to move the data back into the record_id columns where it started
        # before nullifying the driver_record_id columns. I think it should be possible to do this
        # by passing multiple statements to RunSQL, but the order of operations was a bit ambiguous
        # when doing it that way so I moved the data restoration step out to its own set of RunSQL
        # operations in order to be more explicit.
        migrations.RunSQL(
            migrations.RunSQL.noop,  # Do nothing on forward migration
            """UPDATE data_recordduplicate SET record_id = driver_record_id,
               duplicate_record_id = driver_duplicate_record_id;"""
        ),
        migrations.RunSQL(
            migrations.RunSQL.noop,
            'UPDATE data_recordauditlogentry SET record_id = driver_record_id;'
        )
    ]
